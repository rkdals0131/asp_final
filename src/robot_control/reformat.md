# `robot_control` 패키지 심층 분석 및 개선 로드맵 v2.1

## 1. 개요

본 문서는 제공된 `robot_control` ROS 2 패키지의 현재 상태를 비판적으로 분석하고, 이를 전문가 수준의 견고하고 확장 가능한 패키지로 발전시키기 위한 구체적인 개선 방안을 제시합니다. 현재 기능이 정상적으로 작동하는 프로토타입 단계에서, 코드의 품질, 아키텍처의 유연성, 테스트 용이성, 그리고 전반적인 유지보수성을 향상시키는 데 중점을 둡니다.

개발 철학은 **"명시적이고 (Explicit), 예측 가능하며 (Predictable), 테스트 가능한 (Testable) 시스템 구축"** 으로 설정하고, 모든 제안은 이 철학을 기반으로 합니다.

## 2. Part 1: 기반 다지기 (Foundational Improvements)

가장 먼저 수행해야 할 작업들입니다. 코드의 일관성을 확보하고, 잠재적인 버그를 원천 차단하며, 향후 모든 개발의 기초가 되는 안정적인 토대를 마련합니다.

### 1.1. 통합된 코딩 스타일 및 정적 분석 (Linting) 강제

* **현상 및 문제점**: 현재 **`flake8`**, **`pep257`** 테스트가 존재하지만, 이는 최소한의 가이드라인입니다. [] 코드 전반에 걸쳐 네이밍 컨벤션, 줄 바꿈, 주석 스타일 등에서 미세한 비일관성이 발견됩니다. 이는 협업 시나 코드 리뷰 시 가독성을 저해하는 요인이 됩니다.

* **개선 방안**:

  1. **포매터 (Formatter) 도입**: **`black`** 또는 **`autopep8`** 과 같은 코드 포매터를 도입하여 모든 코드에 일관된 스타일을 강제 적용합니다.

  2. **Linter 설정 강화**: **`setup.cfg`** 파일에 **`flake8`** 의 설정을 보다 상세하게 추가합니다. (e.g., 라인 길이 제한, 순환 복잡도 (cyclomatic complexity) 제한 등)

  3. **CI (Continuous Integration) 연동**: GitHub Actions와 같은 CI 도구를 사용하여, 새로운 코드가 Push 되거나 Pull Request가 생성될 때마다 자동으로 linter와 formatter 검사를 수행하도록 구성합니다. 검사를 통과하지 못하면 Merge를 막도록 설정합니다.

* **기대 효과**: 모든 개발자가 동일한 스타일로 코드를 작성하게 되어 가독성이 극대화되고, 코드 리뷰가 스타일에 대한 논쟁이 아닌 로직에 집중할 수 있게 됩니다.

| 개선 효율 | 난이도 (구현/변경 규모) |
| :-------- | :---------------------- |
| 중간      | 낮음                    |

### 1.2. 체계적인 로깅 전략 수립 및 적용

* **현상 및 문제점**: **`print()`** 문, 이모지가 포함된 로그, **"Debug:"**, **"사용자 명령:"** 등 비공식적인 로그 메시지가 코드 전반에 산재해 있습니다. [] 이는 문제 발생 시 원인 추적을 어렵게 하고, 로그의 중요도를 파악하기 힘들게 만듭니다.

* **개선 방안**:

  1. **로깅 레벨 표준화**: ROS 2의 표준 로깅 레벨에 대한 명확한 가이드라인을 수립합니다.

     * **`DEBUG`**: 개발 단계에서 변수 값, 함수 호출 순서 등 상세한 흐름을 추적할 때만 사용. 운영 시에는 비활성화.

     * **`INFO`**: 노드의 시작/종료, 미션의 주요 상태 전이 (e.g., "Takeoff initiated", "Waypoint 3 reached") 등 시스템의 정상적인 동작 흐름을 나타내는 핵심 정보.

     * **`WARN`**: 예상치 못한 상황이지만 시스템이 복구 가능하거나 동작을 계속할 수 있는 경우 (e.g., TF 변환 대기 시간이 길어짐, 서비스 응답이 지연됨).

     * **`ERROR`**: 노드의 정상적인 기능 수행이 불가능한 오류 (e.g., 필수 파라미터 로드 실패, 센서 데이터 수신 중단).

     * **`FATAL`**: 즉시 시스템을 종료해야 하는 심각한 오류.

  2. **전체 코드 리팩토링**: 모든 **`print()`** 문을 **`self.get_logger().<level>()`** 호출로 변경합니다. 로그 메시지에서 이모지와 비공식적인 접두사를 모두 제거하고, 간결하고 명확한 메시지로 통일합니다.

  3. **로그 포맷팅 활용**: **`self.get_logger().info(f'Moving to waypoint {wp_index}: {target_pos}')`** 와 같이 f-string을 활용하여 변수 값을 로그에 명확히 포함시킵니다.

* **기대 효과**: 문제 발생 시 **`rqt_console`** 이나 로그 파일을 통해 오류의 심각도와 발생 위치를 신속하게 파악할 수 있습니다. 시스템의 동작을 실시간으로 명확하게 모니터링할 수 있습니다.

| 개선 효율 | 난이도 (구현/변경 규모) |
| :-------- | :---------------------- |
| 높음      | 중간 (단순 반복 작업)   |

### 1.3. 상태 관리: 문자열에서 Enum으로 완전 전환

* **현상 및 문제점**: **`self.state = "MOVING"`** 과 같이 문자열을 사용하여 상태를 관리하는 방식은 오타에 매우 취약하며, 새로운 상태를 추가하거나 수정할 때 실수를 유발하기 쉽습니다. []

* **개선 방안**:

  1. **`enums.py` 모듈 생성**: **`robot_control/utils/enums.py`** 파일을 생성하고, 시스템에 존재하는 모든 상태 (UAV, UGV, MissionControl 등) 를 Python의 **`Enum`** 클래스로 정의합니다.

  2. **전역 적용**: 모든 노드의 상태 변수와 상태 비교 로직을 **`Enum`** 타입으로 변경합니다.

     ```python
     # 변경 전 (in waypoint_mission.py)
     # self.state = "INIT"
     # if self.state == "TAKING_OFF": ...

     # 변경 후
     from ..utils.enums import DroneState
     self.state = DroneState.INIT
     if self.state is DroneState.TAKING_OFF: ...
     ```

  3. **상태 게시**: 상태를 외부로 게시할 때는 **`self.state.name`** (문자열) 이나 **`self.state.value`** (정수) 를 사용하여 게시하여, 다른 시스템과의 호환성을 유지합니다.

* **기대 효과**: 컴파일 타임에 가까운 수준의 안정성을 확보합니다. 오타로 인한 런타임 버그가 원천적으로 사라지며, IDE의 자동 완성 기능을 통해 개발 속도와 정확성이 향상됩니다.

| 개선 효율   | 난이도 (구현/변경 규모) |
| :---------- | :---------------------- |
| **매우 높음** | 중간                    |

## 3. Part 2: 아키텍처 리팩토링 (Architectural Refactoring)

시스템의 유연성과 확장성을 결정하는 핵심적인 구조 변경입니다. "스파게티 코드"를 해결하고, 각 모듈이 독립적으로 기능하도록 만듭니다.

### 2.1. 로직과 제어의 분리: `PathFollowerNode` 심층 리팩토링

* **현상 및 문제점**: **`PathFollowerNode`** 는 경로 생성 (Spline 보간), 속도 프로파일링 (S-Curve), 경로 추종 제어 (Pure Pursuit), TF 조회 등 너무 많은 책임을 한 클래스에 가지고 있습니다. [] 이는 코드의 복잡도를 높이고, 각 알고리즘을 독립적으로 테스트하거나 재사용하기 어렵게 만듭니다.

* **개선 방안**:

  1. **UGV 로직 모듈화**: UGV 관련 로직은 **`ugv`** 폴더 내에 별도의 스크립트로 모듈화하여 응집도를 높입니다.

  2. **`PathPlanner` 클래스 분리**: **`robot_control/ugv/path_planner.py`** 모듈을 생성하고, 경로 생성과 관련된 모든 로직 (**`_generate_path_points_from_list`**, **`_generate_straight_path`** 등) 을 이 클래스로 옮깁니다.

  3. **`VelocityProfiler` 클래스 분리**: **`robot_control/ugv/velocity_profiler.py`** 모듈을 생성하고, S-Curve 및 곡률 기반 속도 프로파일링 로직 (**`_generate_scurve_velocity_profile`**, **`_calculate_curvature_limited_velocities`** 등) 을 이 클래스로 옮깁니다.

  4. **`PurePursuitController` 클래스 분리**: **`robot_control/ugv/pure_pursuit.py`** 모듈을 생성하고, Pure Pursuit 알고리즘 로직 (**`_find_goal_point`**, **`_find_closest_point_idx`** 등) 을 담당하는 제어기 클래스를 만듭니다.

  5. **`PathFollowerNode` 재설계**: 이제 **`PathFollowerNode`** 는 ROS 통신 (구독/발행, TF 조회) 과 상태 관리에만 집중합니다. 초기화 시 위의 유틸리티 클래스들을 인스턴스화하고, 타이머 콜백에서는 이 클래스들의 메서드를 조립하여 호출하는 역할만 수행합니다.

* **기대 효과**:

  * **단일 책임 원칙 (SRP)** 충족: 각 클래스가 명확한 하나의 책임만 갖게 됩니다.

  * **테스트 용이성**: **`PathPlanner`**, **`VelocityProfiler`** 등은 ROS에 의존하지 않는 순수 Python 클래스가 되므로, **`pytest`** 를 통해 매우 쉽고 빠르게 단위 테스트를 작성할 수 있습니다.

  * **재사용성**: 다른 UGV나 다른 경로 추종 알고리즘을 적용할 때, 필요한 부분만 교체 (e.g., **`PurePursuitController`** 를 **`PIDController`** 로) 하여 쉽게 확장할 수 있습니다.

| 개선 효율   | 난이도 (구현/변경 규모) |
| :---------- | :---------------------- |
| **매우 높음** | 높음                    |

### 2.2. 분산된 시각화 로직 통합 및 중앙화

* **현상 및 문제점**: 현재 시각화 (Marker) 로직이 여러 곳에 분산되어 있습니다.

  * **`PathFollowerNode`**: 경로, 웨이포인트, 속도, 전방주시점 마커를 자체적으로 생성하고 발행합니다. (**`_publish_path_visualization`**, **`_publish_speed_markers`** 등)

  * **`visualization_utils.py`**: UAV 노드들이 사용하는 범용 마커 생성 헬퍼 함수들을 포함합니다.

  * **`marker_visual.py`**: Ground Truth 마커와 탐지된 마커를 시각화하는 별도의 노드입니다.
    이러한 분산 구조는 마커 스타일의 비일관성, 코드 중복, 그리고 로직 노드 (e.g., **`PathFollowerNode`**) 에 불필요한 시각화 책임 부여 등의 문제를 야기합니다.

* **개선 방안**:

  1. **`visualization_utils.py` 기능 강화**: 이 모듈을 모든 종류의 마커를 생성하는 **유일한** 장소로 만듭니다. **`PathFollowerNode`** 내부의 마커 생성 함수들을 **`visualization_utils.py`** 로 옮겨 일반화합니다. (e.g., **`create_speed_profile_marker`**, **`create_lookahead_marker`**)

  2. **중앙 시각화 노드 `MissionVisualizerNode` 도입**:

     * 기존 **`marker_visual.py`** 의 이름을 **`mission_visualizer_node.py`** 로 변경하고 역할을 확장합니다.

     * 이 노드는 시스템의 **모든 시각화** 를 책임집니다.

     * **구독**: **`/marker_detections`**, **`/generated_path`** (from UGV), **`/mission_visuals_data`** (from UAV, 신규 토픽) 등 시각화에 필요한 모든 데이터 토픽을 구독합니다.

     * **발행**: 구독한 데이터를 바탕으로 **`visualization_utils.py`** 를 사용하여 **`MarkerArray`** 를 생성하고, **`/mission_visualization`** 과 같은 단일 토픽으로 발행합니다.

  3. **로직 노드의 책임 분리**:

     * **`PathFollowerNode`** 와 UAV 미션 노드들은 더 이상 **`Marker`** 메시지를 직접 발행하지 않습니다.

     * 대신, 시각화에 필요한 순수 데이터 (e.g., **`nav_msgs/Path`**, 또는 웨이포인트 목록과 현재 상태를 담은 커스텀 메시지) 만을 발행하도록 변경합니다.

* **기대 효과**:

  * **관심사 분리**: 로직 노드는 계산과 제어에만, 시각화 노드는 표시에만 집중하게 됩니다.

  * **일관성**: 모든 마커의 스타일, 색상, 수명 등을 한 곳 (**`visualization_utils.py`**) 에서 관리하므로 시각적 일관성이 보장됩니다.

  * **효율성**: RViz에서 토픽 하나만 구독하면 전체 미션 상황을 볼 수 있어 디버깅이 편리해집니다.

| 개선 효율 | 난이도 (구현/변경 규모) |
| :-------- | :---------------------- |
| 높음      | 높음                    |

### 2.3. Behavior Tree와 PX4 Offboard 제어의 통합 전략

* **현상 및 문제점**: **`mission_control_node`** 의 상태 전이 로직은 복잡한 **`if-elif-else`** 나 딕셔너리 기반 상태 머신으로 구현되어, 시나리오가 복잡해지면 유지보수가 어렵습니다. 한편, Behavior Tree (BT) 가 현재의 PX4 Offboard 제어 방식 (연속적인 Setpoint 발행) 과 어떻게 조화롭게 작동할 수 있을지에 대한 우려가 존재합니다.

* **개선 방안**: **Behavior Tree는 저수준 제어 루프를 대체하는 것이 아니라, 고수준의 목표를 지시하는 '지휘자' 역할을 합니다.**

  1. **두 개의 제어 루프 분리**:

     * **고속 제어 루프 (Fast Control Loop, e.g., 10~20Hz)**: **`BaseMissionNode`** 에 이미 구현된 **`state_machine_timer`** 입니다. 이 루프의 역할은 단 하나, 현재 설정된 목표 자세 (**`target_pose`**) 와 목표 Yaw (**`target_yaw`**) 를 **`TrajectorySetpoint`** 토픽으로 꾸준히 발행하여 드론의 안정적인 비행을 유지하는 것입니다. **이 부분은 그대로 유지합니다.**

     * **저속 의사결정 루프 (Slow Decision Loop, e.g., 1~5Hz)**: Behavior Tree가 이 루프를 담당합니다. BT는 매 "틱(tick)"마다 미션의 현재 상황을 판단하고, **고속 제어 루프가 사용할 목표 값 (`target_pose`, `target_yaw` 등)을 결정하고 설정** 하는 역할을 합니다.

  2. **Behavior Tree Leaf Nodes 재정의**: BT의 가장 말단 노드 (실제 행동) 를 다음과 같이 단순하게 정의합니다.

     * **`SetTargetToWaypoint(wp_index)`**: 이 노드가 실행되면, 단순히 **`self.target_pose`** 를 해당 웨이포인트의 좌표로 설정하고 즉시 **`SUCCESS`** 를 반환합니다. 실제 이동은 고속 제어 루프가 담당합니다.

     * **`IsAtTarget()`**: 이 조건 노드는 **`check_arrival()`** 함수를 호출하여 현재 목표에 도달했는지 확인하고, 그 결과에 따라 **`SUCCESS`** 또는 **`RUNNING`** 을 반환합니다.

     * **`WaitForTopic(topic_name, condition_func)`**: 특정 토픽 메시지가 원하는 조건을 만족할 때까지 **`RUNNING`** 을 반환하는 조건 노드입니다. (e.g., UGV의 상태가 **`COMPLETE`** 가 될 때까지 대기)

  3. **BT와 PX4의 상호작용**:

     * BT가 **`SetTargetToWaypoint(1)`** 을 실행 -> **`self.target_pose`** 가 WP1 좌표로 변경됨.

     * 고속 제어 루프는 변경된 **`self.target_pose`** 를 감지하고, WP1을 향한 **`TrajectorySetpoint`** 을 PX4로 발행 시작.

     * BT는 다음 조건인 **`IsAtTarget()`** 을 계속 체크. 드론이 WP1에 가까워지면 **`check_arrival()`** 이 **`True`** 를 반환하고, **`IsAtTarget()`** 노드가 **`SUCCESS`** 하여 BT의 다음 행동으로 넘어감.

  * 이 구조는 고수준의 유연한 시나리오 관리 (BT) 와 저수준의 안정적인 기체 제어 (Offboard Setpoint 발행) 라는 두 마리 토끼를 모두 잡는 효과적인 방법입니다.

* **기대 효과**:

  * 복잡한 미션 로직을 시각적이고 직관적인 트리 구조로 관리할 수 있습니다.

  * 기존의 안정적인 PX4 Offboard 제어 코드를 거의 수정하지 않고, 고수준의 의사결정 로직만 교체할 수 있습니다.

  * 실패 처리 (Fallback), 조건부 실행 등 복잡한 시나리오를 손쉽게 추가할 수 있습니다.

| 개선 효율 | 난이도 (구현/변경 규모) |
| :-------- | :---------------------- |
| 높음      | **매우 높음** |

## 4. Part 3: 사용성 및 운영 개선 (Usability & Operations)

개발자 및 최종 운영자의 편의성을 높이고, 시스템을 배포하고 관리하는 과정을 개선합니다.

### 3.1. 대시보드 UI/UX 개선

* **현상 및 문제점**: 현재의 **`dashboard_node`** 는 많은 정보를 나열하지만, 운영자가 긴급한 상황에서 가장 중요한 정보를 한눈에 파악하기에는 구조가 다소 복잡합니다. []

* **개선 방안**:

  1. **정보 그룹화 및 계층화**:

     * **[SYSTEM HEALTH]**: 모든 토픽 수신 상태, TF 상태, 노드 활성화 상태를 모아 시스템의 전반적인 '건강'을 한눈에 볼 수 있도록 최상단에 배치합니다.

     * **[MISSION CRITICAL]**: 미션 상태, 경과 시간, 그리고 **가장 중요한 '플랫폼 간 상대 정보'** 를 중앙에 배치합니다.

  2. **'플랫폼 간 상대 정보' 추가**:

     * UAV와 UGV의 절대 좌표 나열보다, **"UAV 기준, UGV는 전방 15.3m, 우측 5.2m, 상공 10.1m에 위치"** 와 같이 상대 벡터를 계산하여 표시합니다. 이는 랑데부 및 정밀 착륙 시 훨씬 직관적인 정보입니다.

     * 두 플랫폼 간의 3D 거리와 2D 수평 거리를 별도로 표시합니다.

  3. **동적 마커 상태 강화**:

     * 정밀 착륙 단계에서 착륙 마커 (e.g., ID 6) 가 탐지되면, 마커의 월드 좌표뿐만 아니라 **드론의 카메라 프레임 기준** 으로 마커의 **수평/수직 오차 (픽셀 또는 미터 단위)** 를 계산하여 표시합니다. 이는 착륙 제어기의 성능을 직관적으로 보여줍니다.

  4. **상태 변경 이력 표시**: 각 플랫폼의 현재 상태 옆에, 괄호 안에 이전 상태를 작게 표시 (e.g., **`MOVING (from PAUSED)`**) 하여 상태가 어떻게 변해왔는지 흐름을 파악하기 쉽게 합니다.

* **기대 효과**: 운영자가 복잡한 숫자들의 나열이 아닌, 미션 수행에 필요한 핵심 정보를 즉각적으로 인지하고 상황 판단을 내리는 데 큰 도움을 줍니다.

| 개선 효율 | 난이도 (구현/변경 규모) |
| :-------- | :---------------------- |
| 중간      | 중간                    |

## 5. Part 4: 테스트 및 검증 (Testing & Validation)

시스템의 신뢰도를 보장하기 위한 마지막 단계입니다. 코드 변경이 다른 부분에 예기치 않은 문제를 일으키지 않았음을 보장합니다.

### 4.1. 핵심 유틸리티 단위 테스트 (Unit Test) 구현

* **현상 및 문제점**: 현재 **`test`** 디렉터리에는 linting 테스트만 존재합니다. [] **`waypoint_parser.py`**, **`drone_control_utils.py`** 등 핵심 로직을 담고 있는 유틸리티 모듈에 대한 기능 테스트가 전무하여, 해당 코드 수정 시 기능이 제대로 동작하는지 수동으로 확인해야 합니다.

* **개선 방안**:

  1. **`pytest` 설정**: **`pytest`** 를 테스트 프레임워크로 사용하고, **`colcon test`** 와 연동되도록 **`setup.py`** 및 **`package.xml`** 을 설정합니다.

  2. **테스트 케이스 작성**:

     * **`waypoint_parser`**: 다양한 형식의 CSV 파일을 입력으로 주었을 때 파싱 결과가 정확한지 테스트합니다.

     * **`drone_control_utils`**: **`point_gimbal_at_target`** 과 같은 수학적 계산 함수의 입력과 기대 출력을 정의하여 테스트합니다.

     * Part 2에서 분리한 **`PathPlanner`**, **`VelocityProfiler`** 등의 순수 Python 클래스들에 대한 테스트를 집중적으로 작성합니다.

  3. **CI 연동**: Linting과 마찬가지로, CI에서 단위 테스트를 자동으로 실행하고 모든 테스트를 통과해야만 Merge가 가능하도록 강제합니다.

* **기대 효과**: 핵심 로직의 안정성을 보장합니다. 리팩토링이나 기능 추가 시 기존 기능이 망가지는 회귀 (regression) 버그를 자동으로 찾아낼 수 있어, 자신감 있게 코드를 수정할 수 있습니다.

| 개선 효율   | 난이도 (구현/변경 규모) |
| :---------- | :---------------------- |
| **매우 높음** | 중간                    |

## 6. 결론 및 추천 로드맵

제안된 개선 사항들을 다음 순서로 진행하는 것을 추천합니다.

1. **1단계 (기반 안정화):** Part 1의 모든 항목 (스타일, 로깅, Enum) 을 먼저 완료합니다. 이는 이후의 모든 작업을 훨씬 수월하게 만들어주는 투자입니다. **(1~2주 소요 예상)**

2. **2단계 (코어 리팩토링 및 테스트):** Part 2의 **`PathFollowerNode`** 리팩토링과 시각화 로직 통합, 그리고 Part 4의 단위 테스트 작성을 병행합니다. 리팩토링으로 분리된 모듈을 바로 테스트로 검증하는 선순환 구조를 만듭니다. **(2~3주 소요 예상)**

3. **3단계 (아키텍처 고도화):** Behavior Tree를 도입하여 미션 제어 로직을 고도화합니다. 이는 시스템의 유연성을 극대화하는 가장 큰 변화가 될 것입니다. **(2~4주 소요 예상)**

4. **4단계 (사용성 개선):** 대시보드 UI/UX 개선은 개발 및 운영 효율을 높여주는 작업으로, 2, 3단계와 병행하거나 이후에 진행할 수 있습니다. **(지속적으로 진행)**

이 로드맵을 따라 체계적으로 개선 작업을 진행한다면, **`robot_control`** 패키지는 단순한 기능 구현체를 넘어, 누구나 신뢰하고 쉽게 확장할 수 있는 매우 높은 수준의 소프트웨어 자산이 될 것입니다.